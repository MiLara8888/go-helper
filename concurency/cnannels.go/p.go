package cnannelsgo

import (
	"fmt"
	"sync"
)

// закрытие канала также является одним из способов одновременной подачи сигнала нескольким
// горутинам. Если у вас есть n горутин, ожидающих на одном канале, вместо того, чтобы писать n раз в
// канал, чтобы разблокировать каждую горутину, вы можете просто закрыть канал.
// Поскольку закрытый канал можно читать бесконечное количество раз, не имеет значения, сколько
// горутин его ожидает
func t() {
	begin := make(chan interface{})
	var wg sync.WaitGroup
	for i := 0; i < 5; i++ {
		wg.Add(1)
		go func(i int) {
			defer wg.Done()
			<-begin
			fmt.Printf("%v has begun\n", i)
		}(i)
	}
	fmt.Println("Unblocking goroutines...")
	close(begin)
	wg.Wait()
}

// func chanT() {
// 	chanOwner := func() <-chan int {
// 		// 	Здесь мы создаем экземпляр буферизованного канала. Поскольку мы знаем, что получим шесть
// 		// результатов, мы создаем буферизованный канал из пяти, чтобы горутина могла завершиться как
// 		// можно быстрее.
// 		resultStream := make(chan int, 5)
// 		// 		Здесь мы запускаем анонимную горутину, которая выполняет запись в resultStream.
// 		// Обратите внимание, что мы поменяли порядок создания горутин. Теперь он инкапсулирован в
// 		// окружающую функцию.
// 		go func() {
// 			// Здесь мы гарантируем, что resultStream закроется, как только мы закончим с ним. Это наша
// 			// ответственность как владельца канала.
// 			defer close(resultStream)
// 			for i := 0; i <= 5; i++ {
// 				resultStream <- i
// 			}
// 		}()
// 		// Здесь мы возвращаем канал. Поскольку возвращаемое значение объявлено как канал только для
// 		// чтения, resultStream будет неявно преобразован в канал только для чтения для потребителей.
// 		return resultStream
// 	}
// 	resultStream := chanOwner()
// 	// Здесь мы переходим к resultStream. Нас, как потребителя, беспокоит только блокировка и закрытие
// 	// каналов.
// 	for result := range resultStream {
// 		fmt.Printf("Received: %d\n", result)
// 	}
// 	fmt.Println("Done receiving!")
// }
